{#if error}
<div>
    <code><pre>{error.toString()}</pre></code>
</div>
{/if}

<div>
    <button on:click="addfile()">➕</button>
</div>

{#each [ ...files.entries() ] as [ file, text ] (file)}
<div>
    <h2>{file} <button on:click="deletefile(file)">♻</button></h2>
    <textarea on:input="updatefile(file, this.value)">{text}</textarea>
</div>
{/each}

<div>
    <h2>CSS</h2>
    <code><pre>{css}</pre></code>
</div>

<div>
    <h2>Compositions</h2>
    {#each Object.entries(compositions) as [ file, props ] (file)}
    <h4>{file}</h4>
    <dl>
        {#each Object.entries(props) as [ key, value ]}
        <dt>.{key}</dt>
        <dd>"{value}"</dd>
        {/each}
    </dl>
    {:else}
    No data yet
    {/each}
</div>

<script>
import fs from "fs";
import path from "path";

import Processor from "@modular-css/processor";
import debounce from "p-debounce";

const processor = new Processor({
    cwd : "/",

    // Custom file resolver to work around gaps in fake node environment
    resolvers : [
        (src, file, resolve) => path.resolve(`/${file}`),
    ],
});

let process;

export default {
    data : () => ({
        files : new Map([
            [ "/styles.css", `.foo { color: red; }` ],
            [ "/other.css", `.foo { composes: foo from "styles.css"; }` ],
        ]),
        
        css  : "",
        compositions : [],

        error : false,
    }),

    methods : {
        deletefile(file) {
            const { files } = this.get();

            files.delete(file);

            fs.unlinkSync(file);

            processor.remove(file);

            this.set({
                // Trigger redraw
                files,

                // Hope for the best!
                error : false,
            });
        },

        updatefile(file, text) {
            const { files } = this.get();

            files.set(file, text);

            fs.writeFileSync(file, text, "utf8");

            if(file in processor.files) {
                processor.invalidate(file);
            }

            // Purposefully NOT awaiting here, it'll finish processing eventually
            // and do the right thing when it finishes, we don't need to worry about it
            processor.file(file);

            this.set({
                // trigger reactivity by re-assigning the map over top of itself
                files,

                // Hope for the best
                error : false
            });
        },

        addfile() {
            const { files } = this.get();

            files.set(`/${files.size + 1}.css`, "");

            this.set({
                files,
            });
        }
    },

    oncreate() {
        const output = async (...args) => {
            try {
                const { css, compositions } = await processor.output();

                
    
                return this.set({
                    css,
                    compositions,
                });
            } catch(error) {
                console.error(error);

                return this.set({ error });
            }
        };

        this.output = debounce(output, 250);

        const { files } = this.get();

        files.forEach((text, file) => {
            this.updatefile(file, text);
        });
    },

    onstate({ changed, current, previous }) {
        if(!changed.files || !previous) {
            return;
        }

        this.output();
    }
};
</script>
