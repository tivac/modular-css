<style type="text/css">
body {
    font-family: 'Roboto', sans-serif;

    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
}

pre,
textarea,
:global(.CodeMirror) {
    font-family: 'Inconsolata', monospace;
}

.page {
    width: 100%;
    height: 100%;

    display: grid;

    grid:
        "input output";
    grid-gap: 0 5%;
}

.input {
    grid-area: "input";
}

.tabs {
    display: flex;
    flex-direction: row;
    justify-content: flex-start;
    align-items: stretch;
}

.tab {}

.tabon {
    composes: tab;
}

.add {}

.file {}

.remove {}

.output {
    grid-area: "output";
}

.error {}

.erroron {}

.result {}

.compositions {}

</style>

<div class="{css.page}">
    <div class="{css.input}">
        <div class="{css.tabs}">
            <button class="{css.add}" on:click="$add()">➕</button>
            
            {#each [ ...$files.values() ] as file (file)}
            <div class="{tab === file ? css.tabon : css.tab}">
                <button class="{css.file}" on:click="this.set({ tab : file })">{file}</button>
                <button class="{css.remove}" on:click="$remove(file)">♻</button>
            </div>
            {/each}
        </div>

        <Editor file={tab} error={$error.file === tab ? $error : false} />
    </div>

    <div class="{css.output}">
        <div class="{error ? css.erroron : css.error}">
            {error ? error.toString() : ""}
        </div>

        <div class="{css.result}">
        {#await loading}
            <div class="loading">Loading editor...</div>
        {:then _}
            <div class="output">
                <textarea ref:output></textarea>
            </div>
        {:catch err}
            <div class="loaderror">Unable to load editor</div>
        {/await}
        </div>

        <div class="{css.compositions}">
            <!-- This is silly, need a better story here... -->
            <!--
            {#each Object.entries($compositions).reverse() as [ file, props ] (file)}
            <h4>{file}</h4>
            <dl>
                {#each Object.entries(props) as [ key, value ]}
                <dt>.{key}</dt>
                <dd>"{value}"</dd>
                {/each}
            </dl>
            {:else}
            No data yet
            {/each}
            -->
        </div>
    </div>
</div>

<script>
import store from "./store.js";

export default {
    components : {
        Editor : "./editor.html",
    },

    store : () => store,

    data : () => {
        const { files } = store.get();

        return {
            loading : import("./codemirror.js"),

            // iterators are so much fun
            tab : files.values().next().value,
        };
    },

    oncreate() {
        const { loading } = this.get();

        // Instantiate codemirror once it's loaded
        loading.then((mod) => {
            const { codemirror, theme } = mod;

            this.cm = codemirror.fromTextArea(this.refs.output, {
                lineNumbers : true,
                lineWrapping : true,
                indentUnit : 4,
                readOnly : true,
                mode : "text/css",
                theme,
            });

            const { css } = this.store.get();

            this.cm.setValue(css);
        });

        this.store.on("state", ({ changed, current }) => {
            if(!changed.css || !this.cm) {
                return;
            }

            const { css } = current;

            this.cm.setValue(css);
        });
    },
};
</script>
