<link rel="stylesheet" href="./app.css" />

{#if error}
<div>
    <code><pre>{error.toString()}</pre></code>
</div>
{/if}

<div>
    <button on:click="addfile()">➕</button>
</div>

{#each [ ...files.values() ] as file (file)}
    <h2>{file} <button on:click="deletefile(file)">♻</button></h2>

    <Editor {file} error="{error.file === file ? error : false}" on:input="oninput(file)"/>
{/each}

<div>
    <h2>CSS Output</h2>
    {#await loading}
        <div class="loading">Loading editor...</div>
    {:then _}
        <div class="output">
            <textarea ref:output></textarea>
        </div>
    {:catch err}
        <div class="loaderror">Unable to load editor</div>
    {/await}
</div>

<div>
    <h2>Compositions</h2>
    <!-- This is silly, need a better story here... -->
    {#each Object.entries(compositions).reverse() as [ file, props ] (file)}
    <h4>{file}</h4>
    <dl>
        {#each Object.entries(props) as [ key, value ]}
        <dt>.{key}</dt>
        <dd>"{value}"</dd>
        {/each}
    </dl>
    {:else}
    No data yet
    {/each}
</div>

<script>
import fs from "fs";
import path from "path";

window.fs = fs;

import Processor from "@modular-css/processor";
import debounce from "p-debounce";
import lz from "lznext";

const processor = new Processor({
    cwd : "/",

    // Custom file resolver to work around gaps in fake node environment
    resolvers : [
        (src, file, resolve) => path.resolve(`/${file}`),
    ],
});

let initialFiles;

if(location.hash) {
    const hash = location.hash.substring(1);

    try {
        const data = JSON.parse(lz.decompressFromBase64(hash));

        console.log(data);

        initialFiles = new Set();

        // TODO: since .update is never called the editor doesn't know about the file on disk
        // TODO: Need to solve before persistence can work :(
        data.forEach(([ file, css ]) => {
            initialFiles.add(file);

            fs.writeFileSync(file, css, "utf8");
        });
    } catch(e) {
        console.warn("Unable to parse state", hash);
    }
} else {
    initialFiles = new Set([ "/styles.css "]);

    fs.writeFileSync("/styles.css", "", "utf8");
}

export default {
    components : {
        Editor : "./editor.html",
    },

    data : () => ({
        files : initialFiles,
        
        css  : "",
        compositions : [],

        error : false,

        loading : import("./codemirror.js").then((m) => m.default),
    }),

    methods : {
        oninput(file) {
            this.update(file);
        },

        deletefile(file) {
            const { files } = this.get();

            files.delete(file);

            processor.remove(file);

            this.output();

            // Trigger redraw
            this.set({ files });
        },
        
        addfile() {
            const { files } = this.get();

            files.add(`/${files.size + 1}.css`);

            this.set({ files });
        }
    },

    oncreate() {
        this.output = debounce(async (...args) => {
            try {
                const { files } = this.get();
                const { css, compositions } = await processor.output();

                // Update location.hash with fs state
                const hash = [ ...files.values() ].map((file) => ([
                    file,
                    fs.readFileSync(file, "utf8")
                ]));

                location.hash = lz.compressToBase64(JSON.stringify(hash));
    
                return this.set({
                    error : false,

                    css,
                    compositions,
                });
            } catch(error) {
                console.warn("Error generating output", error);

                return this.set({ error });
            }
        }, 250);

        this.update = async (file) => {
            console.log("update", file);

            if(file in processor.files) {
                processor.invalidate(file);
            }

            try {
                await processor.file(file);
            } catch(error) {
                console.warn(`Error parsing "${error.file}"`, error);

                return this.set({ error });
            }

            return this.output();
        };

        const { files, loading } = this.get();

        // Load files into the processor
        files.forEach(this.update);

        // Instantiate codemirror once it's loaded
        loading.then((codemirror) => {
            this.cm = codemirror.fromTextArea(this.refs.output, {
                lineNumbers : true,
                lineWrapping : true,
                indentUnit : 4,
                readOnly : true,
                theme : "mdn-like",
                mode : "text/css",
            });
        });
    },

    onstate({ changed, current, previous }) {
        if(!previous) {
            return;
        }

        if(changed.files) {
            this.output();
        }

        if(changed.css) {
            const { css } = current;

            this.cm.setValue(css);
        }
    }
};
</script>
